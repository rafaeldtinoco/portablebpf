# eBPF CO.RE code example
### bonus 1: compatible with BCC<BR>bonus 2: userland portion in C and Python ([bpfcc-supported](https://github.com/rafaeldtinoco/portablebpf/tree/bpfcc-supported))<BR>bonus 3: compatible with v4.x.y kernels

My original intent was to create an eBPF code that could be coded in C and be portable among different kernels. I had a specific project in mind - [ipsetaudit](https://github.com/rafaeldtinoco/ipsetaudit), a tool capable of auditing calls to ipset - and during the development there were so many caveats - that had to be investigated in mailing lists or using the old try-n-error approach - I decided to document them here with a code example that could be used by anyone willing to create an eBPF tool from the beginning.

## eBPF libraries

There are currently 2 main eBPF libraries:

1. BCC: compiles the eBPF code during code execution, loads the eBPF bytecode in kernel and makes userland app to get shared information from the eBPF code through BPF MAPS.

    - [BCC project](https://github.com/iovisor/bcc)
    - [BCC reference guide](https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md)
    - [BCC python developer](https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md)

2. libbpf: compiles the eBPF (and user-land) code before the execution. The library is responsible for making eBPF bytecode symbol relocations BEFORE loading it into kernel, making the binary portable among different kernels. For that, libbpf needs kernel to support BTF (latest kernels support).

    - [libbpf project](https://github.com/libbpf/libbpf)
    - [BPF portability and CO-RE](https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html)
    - [BCC to BPF conversion](https://facebookmicrosites.github.io/bpf/blog/2020/02/20/bcc-to-libbpf-howto-guide.html)

And this example uses the 2:

1. BCC: **mine.py**: a BCC based python app that will compile the same bpf code (ipsetaudit.bpf.c) during its runtime.
    - This example has been removed from main branch to make it simpler and easier to read.
    - I created a branch called [bpfcc-supported](https://github.com/rafaeldtinoco/portablebpf/tree/bpfcc-supported) showing this example.

2. libbpf: **mine**: a pre-compiled and portable libcc based binary with bpf bytecode embedded on it. This binary will be able to run in any kernel supporting BTF.

    - [Diving into BPF](https://qmonnet.github.io/whirl-offload/2016/09/01/dive-into-bpf/)
    - [Kernel eBPF features by version](https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md)
    - [Older kernels and eBPF global data](https://lwn.net/Articles/784936/)

## The file tree explained

**Makefile**

Will magically generate a binary called "mine", statically linked with libbpf library (downloaded as a git submodule of this tree).

**mine**

This binary will be portable and executed in any kernel supporting BPFs and the BTF format (there is a trick[1] to make BTF available in older kernels, like the v4.x series).

**mine.bpf.c**

This is the **eBPF source code**. It will generate the bytecode that will be executed inside the kernel BPF virtual machine. When coding eBPF programs, one usually uses either the **BPFCC (old BCC)** or, the most recent, **libbpf** library. _This example is compatible with both_. If you are creating an eBPF tool that is only going to run in newer kernels you would stick with **libbpf** only.

> In this example we have a single kernel probe declared that will be fired every time the **ip_set_create** kernel function is called. This was chosen because in order for me to get *ipset* events I had to see what functions were called by the netlink handlers whenever a netlink message of ipset type was received by kernel.

**mine.c**

This is the userland portion of my eBPF tool. This is a regular user-land code made in C but, in this case, for the way we are building it, it shares code with a common - to the eBPF code - header file (mine.h). This code is responsible to get information out of BPF maps - shared among the eBPF code, running inside the kernel, and the user-land code and deal with it.

> This file is part of the libbpf based binary only.

**mine.h**

This is header file that is shared among the 2 codes: the eBPF C code, in mine.bpf.c, and the userland C code, in mine.c.

> If you are using libbpf only, then this file won't have much but the structs responsible to describe the BPF maps you want to share among kerne and userland.

**vmlinux.h**

This file is generated by doing:

```
tools/bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h
``` 
in a kernel supporting BTF. eBPF programs are VERY tied to kernel internals if you are using kprobes, for example. The Linux kernel project tries to keep a list of stable events you can subscribe to without needing to rely on internal data structures that are subjected to changes.

Unfortunately the available list of events is far from perfect and you will find yourself probing internal functions to get from the kernel the data you want. Whenever you probe internal structures that have no ABI guarantees, you will realize your eBPF code is not *that portable*.

Nevertheless, differently than BCC project, where your code had to include the headers that you were acting on, libbpf thought about a way to have a single include file describing all kernel data structures, so you don't have to worry about it.

> You will find 2 vmlinux.h header files included in this git tree. One was generated in an older kernel and the other in a recent one. Fortunately the structures we are using here don't change from one to another, so, compiling the eBPF with the vmlinux.h from kernel v4.15 was good enough for my binary to be portable among the two.

**patches/***

Contains patch(es) for some workarounds to get the libbpf version of this example tool running in older kernels. If you are running this in a recent kernel.

**THERE IS NO NEED TO READ THIS ON RECENT KERNELS (only if you are curious)**

 - [1] trick: as stated before, if you are running this in an older kernel it won't support BTF. Without getting into too many details, BTF is a very simple and small way to inform about all needed rellocations a pre-compiled eBPF bytecode would need for the current running kernel.

 > If you run: 
 > 
 > ```
 > $ FILE=/sys/kernel/btf/vmlinux
 > $ tools/bpftool btf dump file $FILE format c > vmlinux.h
 > ```
 >
 > in a recent kernel you will get a header file describing all existing types for the current kernel, for example.

 I have made some tricks in this example to make sure the libbpf based generated binary would also be portable to a 4.x kernel. By using these tricks, you will be able to compile a single binary and run it in an old kernel (v4.15, for example) and a new one (v5.x), without recompiling generated binary.
 
 There are 2 ways to get BTF generated in older kernels. Unfortunately there is no way, without backporting sets of patches, to make /sys/kernel/btf/vmlinux available so we have to rely in a file containing all the BTF information for the running kernel. Just like a debug file would do but in a much (~10x) smaller way.
 
  1. The first option is to get the BTF generated in a vmlinux file, as one of its ELF sections. If you use this kernel libbpf will get the BTF information from this kernel right away (unless you strip vmlinux like all distros do, then you would have to have the .BTF section in the vmlinux file contained in the debug package for the kernel being generated).
  
  * So, let's say you want to have a bionic kernel compatible to libbpf generated binaries. You can apply the patch **patches/link-vmlinuz.sh.patch** to its kernel git tree (git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/bionic) and recompile the kernel.
 
  ```
  $ patch -p1 < ~/portablebpf/patches/link-vmlinuz.sh.patch
  $ git commit ./scripts/link-vmlinuz.sh --ammend
  $ export DEB_BUILD_OPTIONS="nocheck nodoc noopt udeb debug"
  $ fakeroot debian/rules
  $ dpkg-buildpackage -uc -us -b -rfakeroot -I.git -I.gitignore -i'\.git.*'
  ```
  
  * Once that is done simply installing the linux-image-xxxx-dbgsym.ddeb generated package will get you an ELF file `/usr/lib/debug/boot/vmlinux` containing a .BTF section. That will be enough for libbpf to work and do all needed relocations for the BTF object our binary will load into kernel.

  * The libbpf library checks for ELF files containg the BTF section in the following paths:

  ```C
  locations[] = {
    /* try canonical vmlinux BTF through sysfs first */
    { "/sys/kernel/btf/vmlinux", true /* raw BTF */ },
    /* fall back to trying to find vmlinux ELF on disk otherwise */
    { "/boot/vmlinux-%1$s" },
    { "/lib/modules/%1$s/vmlinux-%1$s" },
    { "/lib/modules/%1$s/build/vmlinux" },
    { "/usr/lib/modules/%1$s/kernel/vmlinux" },
    { "/usr/lib/debug/boot/vmlinux-%1$s" },
    { "/usr/lib/debug/boot/vmlinux-%1$s.debug" },
    { "/usr/lib/debug/lib/modules/%1$s/vmlinux" },
  };
  ```
  
  * That is why only having a -dbgsym package installed (as long as it was generated with the link-vmlinuz.sh patch applied) is enough.

  2. The other option is the one I prefer. It allows you to run your eBPF binary in older kernels without having them changed. There is a tool called **pahole** from [acme](https://acmel.wordpress.com/)'s [dwarves project](https://github.com/acmel/dwarves).
  
  * This second option is described bellow, after the compilation instructions.

# Compilation and Execution

## 1. Compiling libbpf based binary

Run **make** and it will compile the **mine** binary file:

```
$ make -j20
mkdir -p .output
mkdir -p .output/libbpf
make -C /home/rafaeldtinoco/devel/portablebpf/libbpf/src \
	BUILD_STATIC_ONLY=1 \
	OBJDIR=/home/rafaeldtinoco/devel/portablebpf/.output/libbpf \
	DESTDIR=/home/rafaeldtinoco/devel/portablebpf/.output \
	INCLUDEDIR= LIBDIR= UAPIDIR= install
make[1]: Entering directory '/home/rafaeldtinoco/devel/portablebpf/libbpf/src'
  MKDIR    staticobjs
  INSTALL  bpf.h libbpf.h btf.h xsk.h libbpf_util.h bpf_helpers.h bpf_helper_defs.h bpf_tracing.h bpf_endian.h bpf_core_read.h libbpf_common.h
  CC       bpf.o
  CC       btf.o
  CC       libbpf.o
  CC       libbpf_errno.o
  CC       netlink.o
  CC       nlattr.o
  CC       str_error.o
  CC       libbpf_probes.o
  CC       bpf_prog_linfo.o
  CC       btf_dump.o
  CC       xsk.o
  CC       hashmap.o
  CC       ringbuf.o
  INSTALL  libbpf.pc
  AR       libbpf.a
  INSTALL  libbpf.a
make[1]: Leaving directory '/home/rafaeldtinoco/devel/portablebpf/libbpf/src'
clang -g -O2 -target bpf -D__TARGET_ARCH_x86 \
	     -I.output -I. -c mine.bpf.c -o .output/mine.bpf.o && \
llvm-strip -g .output/mine.bpf.o
/home/rafaeldtinoco/devel/portablebpf/tools/bpftool gen skeleton .output/mine.bpf.o > .output/mine.skel.h
clang -g -O2 -Wall -I.output -I. -c mine.c -o .output/mine.o
clang -g -O2 -Wall .output/mine.o /home/rafaeldtinoco/devel/portablebpf/.output/libbpf.a -lelf -lz -o mine
rm .output/mine.bpf.o
```

After the compilation, I can execute it in **ANY other host* - running a recent enough kernel that supports BTF - without recompiling it:

```
Tracing... Hit Ctrl-C to end.
(2021/03/19_01:01) ipset (pid: 17436) (username: rafaeldtinoco - uid: 1000) - CREATE test123 (type: hash:ip)
(2021/03/19_01:01) ipset (pid: 17437) (username: rafaeldtinoco - uid: 1000) - CREATE test456 (type: hash:ip)
(2021/03/19_01:01) ipset (pid: 17438) (username: rafaeldtinoco - uid: 1000) - CREATE test789 (type: hash:ip)
```

The commands that caused the events above are:

```
$ sudo ipset create test123 hash:ip
$ sudo ipset create test456 hash:ip
$ sudo ipset create test789 hash:ip
```

> Note that (-v) option will give you important debug information (verbose) of libbpf internals. It is important to understand all work libbpf does under the hood when loading the binary, rellocating all eBPF bytecode symbols using BTF information caught either from sysfs (recent kernels) or a .BPF section of an ELF file (older kernels).

## Portable libbpf based ebpf code: Older Kernels

To prove **THE SAME BINARY** might work in an older kernel version as well, after compiling this code in an Ubuntu Groovy environment, I'll run it in a Bionic host, with a much older kernel (5.8 -> 4.15).

Since the older kernels do not generate the .BTF ELF section by default - reason for patches/link-vmlinux.sh.patch to exist - we have to install the kernel debug symbols (DWARF) and convert them to the BTF format with pahole tool (recent versions):

```
$ uname -a

$ cat /etc/apt/sources.list | grep ddeb
deb http://ddebs.ubuntu.com bionic main restricted universe multiverse
deb http://ddebs.ubuntu.com bionic-updates main restricted universe multiverse
deb http://ddebs.ubuntu.com bionic-proposed main restricted universe multiverse

$ apt-get install linux-image-4.15.0-139-generic linux-headers-4.15.0-139-generic linux-modules-4.15.0-139-generic linux-modules-extra-4.15.0-139-generic linux-image-4.15.0-139-generic-dbgsym
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  linux-headers-4.15.0-139 linux-image-unsigned-4.15.0-139-generic-dbgsym
Suggested packages:
  fdutils
The following NEW packages will be installed:
  linux-headers-4.15.0-139 linux-headers-4.15.0-139-generic linux-image-4.15.0-139-generic linux-image-4.15.0-139-generic-dbgsym
  linux-image-unsigned-4.15.0-139-generic-dbgsym linux-modules-4.15.0-139-generic linux-modules-extra-4.15.0-139-generic
0 upgraded, 7 newly installed, 0 to remove and 23 not upgraded.
Need to get 855 MB of archives.
After this operation, 5,862 MB of additional disk space will be used.
Do you want to continue? [Y/n]
...
```

Boot in the new kernel:

```
$ uname -a
Linux IBM 4.15.0-139-generic #143-Ubuntu SMP Tue Mar 16 01:30:17 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
```

Make sure you have a recent dwarves package installed:

```
$ dpkg-query -f '${Package} ${Version}\n' -W 'dwarves'
dwarves 1.17-1 
```

Install llvm-10 and clang-10 (or llvm-11 and clang-11 if available) and update alternatives:

```
$ sudo update-alternatives --install /usr/bin/clang clang $(which clang-10) 1
$ sudo update-alternatives --install /usr/bin/llvm-strip llvm-strip $(which llvm-strip-10) 1
$ sudo update-alternatives --install /usr/bin/llvm-objcopy llvm-objcopy $(which llvm-objcopy-10) 1
```

Use pahole tool to add the .BTF ELF section to vmlinux file from the debug package:

```
$ sudo pahole -J /usr/lib/debug/boot/vmlinux-$(uname -r)
```

Extract the .BTF section from vmlinux file into a new file to be used by libbpf. This file will contain a *SINGLE .BTF section* that will serve to libbpf as information for needed relocations during the BPF program load.

> Note: the newer kernels provide this at: /sys/kernel/btf/vmlinux
> so there is no need to have an external (to kernel) file providing
> that info

```
$ sudo llvm-objcopy-10 --only-section=.BTF --set-section-flags .BTF=alloc,readonly --strip-all /usr/lib/debug/boot/vmlinux-$(uname -r) /boot/vmlinux-$(uname -r)

$ ls -lah /boot/vmlinux-$(uname -r)
-rw-r--r-- 1 root root 32M Mar 19 01:27 /boot/vmlinux-4.15.0-139-generic
```

As you can see, we have generated a stripped ELF containing a .BTF section that will inform libbpf about all types we have for this kernel. This file is still big, 32M in this case, and we can strip it even more:

> The reason for that file to be named /boot/vmlinux-$(uname -r) is that
> this is a place where libbpf will look for an ELF containing BTF section
> so, with that filename, we don't need to patch libbpf

```
$ sudo strip -x /boot/vmlinux-$(uname -r)
strip: /boot/stWykhS6: warning: allocated section `.BTF' not in segment

$ ls -lah /boot/vmlinux-$(uname -r)
-rw-r--r-- 1 root root 3.0M Mar 19 01:30 /boot/vmlinux-4.15.0-139-generic
```

Now we currently have a 3MB file that will serve for that purpose. Good enough. We can get rid of the kernel debug symbols. 

> This ELF file (/boot/vmlinux-4.15.0-139-generic) containing BTF data will, likely, be good enough for other kernel versions close to this one (depending on the changes to the data types). So, in *theory* you could just rename this file to 4.15.0-{140,141,142}-generic and, as long as the data types used by the kernel functions you are probing don't change, you would be good.

Together with this ELF (/boot/vmlinux-$(uname -r)) we will be able to run the same compiled binary (in Ubuntu Groovy) in this Ubuntu Bionic.

```
$ apt-get remove --purge linux-image-4.15.0-139-generic-dbgsym
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following package was automatically installed and is no longer required:
  linux-image-unsigned-4.15.0-139-generic-dbgsym
Use 'sudo apt autoremove' to remove it.
The following packages will be REMOVED:
  linux-image-4.15.0-139-generic-dbgsym*
0 upgraded, 0 newly installed, 1 to remove and 23 not upgraded.
After this operation, 21.5 kB disk space will be freed.
Do you want to continue? [Y/n] y
```

Right, let's try it:

```
$ uname -a
Linux IBM 4.15.0-139-generic #143-Ubuntu SMP Tue Mar 16 01:30:17 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux

$ sudo modprobe ip_set # DON'T FORGET TO LOAD MODULE

$ sudo ./mine
Foreground mode...<Ctrl-C> or or SIG_TERM to end it.
libbpf: load bpf program failed: Invalid argument
libbpf: failed to load program 'ip_set_create'
libbpf: failed to load object 'mine_bpf'
libbpf: failed to load BPF skeleton 'mine_bpf': -22
failed to load BPF object: -22
line 287, file mine.c, function main
```

Wait ? So... what is wrong ? **UNFORTUNATELY** old kernels, like 4.15.18, the kernel which Ubuntu Bionic is based on, check for a BPF binary attribute "kernel version". In the past, kernel developers tried cope with kernel ABI instability by blocking BPFs compiled for different kernels. This is no longer true but older kernels still have that check.

> I'm currently suggesting to upstream libbpf project a way to have the kern_version attribute changed at run time. This method is already present here if you apply patches/* to libbpf directory BUT it will be changed until accepted.

With the current patches you can:

```
$ export LIBBPF_KERN_VERSION=4.15.18

$ sudo -E ./mine
Foreground mode...<Ctrl-C> or or SIG_TERM to end it.
Tracing... Hit Ctrl-C to end.
```

And voilÃ¡! We just compiled an eBPF program in an Ubuntu Groovy host, running kernel 5.8.0-43-generic, and ran the EXACT SAME BINARY in an Ubuntu Bionic, running kernel 4.15.0-139-generic with NO CHANGES to existing kernels OR our compiled binary.

> The eBPF binary instrospected both kernels, looking for the same symbol (**ip_set_create**) and added a kprobe to those. This allowed the userland code to inform about what **ipset** attributes were given to kernel after kernel received **ipset netlink msgs** (like an audit tool would do).

